---
title: "Graph mining"
author: "Magda Bolewska"
date: "6 février 2019"
output: html_document
---

## 1 - Importation de données et traitements préliminaires

```{r}
library(data.table)
library(lubridate)
library(magrittr)
library(igraph)
library(visNetwork)
```


```{r}

rm(trips)

trips_filename <- list.files('data_raw', pattern = 'divvy_trips_[0-9]{4}(_[0-9]{2}){2}_.*\\.csv', full.names = TRUE) %>% max()
trips_filename
trips <- fread(trips_filename, na.strings = c(""))

trips[
  , 
  `:=`(
    start_time = as_datetime(start_time),
    stop_time = as_datetime(stop_time)
  ), 
  ]

trips[, weekday := lubridate::wday(start_time, label=TRUE, abbr = FALSE)]
trips[, hr_depart := hour(start_time)]

```



# Attribution du nom et des coordonnées géographiques uniques à chaque station
```{r}

nc_stations <- trips[!duplicated(trips[, from_station_id]),.(from_station_id,from_station_name,from_latitude,from_longitude) ]

trips$from_station_name <- NULL
trips$from_latitude <- NULL
trips$from_longitude <- NULL
trips$to_station_name <- NULL
trips$to_latitude <- NULL
trips$to_longitude <- NULL



trips <- merge(trips,nc_stations,by= c("from_station_id"))

setnames(nc_stations, old = c("from_station_id", "from_station_name","from_latitude","from_longitude"), new = c("to_station_id", "to_station_name","to_latitude","to_longitude"))

trips <- merge(trips,nc_stations,by= c("to_station_id"))
summary(trips)

```


## 2 - Construction du graphe

# Construction de la matrice de co-occurences
```{r}
co_occ_oriented <- trips[,.N, by=.(to_station_id,from_station_id)]
```


```{r}
colnames(co_occ_oriented)
```

# Construction du graphe orienté à partie de la matrice de co-occurences
```{r}
g <- graph.data.frame(co_occ_oriented,directed = T)
```


# Première visualisation
```{r}
visIgraph(g)
```
Le graphe ne s'affiche pas !!! A voir pourquoi ?! Trop de connections ?


# Est-ce que le graphe est connecté ? TRUE
```{r}
is.connected(g)
```

# Distribution des composantes connectées fortement (pour lesquelles tous les noeuds peuvent être reliés dans les deux senses)
```{r}
components=components(g,"strong")
table(components$csize)
```

Si le graphe est connecté, pourquoi il affiche 2 composantes ?


## 3 - Métriques globales

# Densité : nombre de liens / nombre de liens possibles
```{r}
graph.density(g)
```

# Transitivité
```{r}
transitivity(g)
```

# Nombre moyen de voisins directs
```{r}
mean(degree(g))
```


# Distance moyenne entre deux noeuds du graphe
```{r}
average.path.length(g)
```

# La plus grande distance observée entre deux noeuds du graphe ie on ignore les noeuds non connectés
```{r}
E(g)$weight=1
diametre=diameter(g) 
diametre
```


## 4 - Métriques locales
```{r}
E(g)$weight=1
is.connected(g)
```


```{r}
centrality<-data.frame(index=V(g)$name, 
                       degre=degree(g,mode = "all"),#nombre de voisins directs
                       degre_in=degree(g,mode = "in"),#nombre de voisins qui émettent un flux vers le noeud
                       degre_out=degree(g,mode = "out"),#nombre de voisins qui reçoivent un flux du noeud

                       inter=betweenness(g), #intermédiarité ie nombre de fois que le noeud sert de plus court chemin
                       prox=closeness(g), #proximité, inverse de la distance moyenne du noeud vers n'importe quel autre
                       trans=transitivity(g,type="local"),
                       stringsAsFactors = F) #coefficient de clustering, on compte le nombre de triangles ie xRy & yRz => xRz
```


A suivre !