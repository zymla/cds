---
title: "Graph mining"
author: "Magda Bolewska"
date: "6 février 2019"
output: html_document
---

## 1 PREPARATION DES FICHIERS POUR SHINY

```{r}
library(data.table)
library(lubridate)
library(magrittr)
library(igraph)
library(visNetwork)
```


```{r}

rm(trips)

trips_filename <- list.files('data_raw', pattern = 'divvy_trips_[0-9]{4}(_[0-9]{2}){2}_.*\\.csv', full.names = TRUE) %>% max()
trips_filename
trips <- fread(trips_filename, na.strings = c(""))

trips$from_station_id <- as.character(trips$from_station_id)
trips$to_station_id <- as.character(trips$to_station_id)

trips[, weekday := lubridate::wday(start_time, label=TRUE, abbr = FALSE)]
trips[, hr_depart := hour(start_time)]

```

# Attribution du nom et des coordonnées géographiques uniques à chaque station
```{r}

nc_stations <- trips[!duplicated(trips[, from_station_id]),.(from_station_id,from_station_name,from_latitude,from_longitude) ]

trips$from_station_name <- NULL
trips$from_latitude <- NULL
trips$from_longitude <- NULL
trips$to_station_name <- NULL
trips$to_latitude <- NULL
trips$to_longitude <- NULL

trips <- merge(trips,nc_stations,by= c("from_station_id"))

setnames(nc_stations, old = c("from_station_id", "from_station_name","from_latitude","from_longitude"), new = c("to_station_id", "to_station_name","to_latitude","to_longitude"))

trips <- merge(trips,nc_stations,by= c("to_station_id"))

fichier_graphe <- trips[,.N, by= . (from_station_id, to_station_id, weekday, hr_depart )]
head(fichier_graphe)

setnames(nc_stations, old = c("to_station_id", "to_station_name","to_latitude","to_longitude"), 
         new = c("id","station_name","latitude","longitude"))
```


# Récupération de la taille des stations
```{r}
rm(stations)

stations_filename <- list.files('data_raw', pattern = 'divvy_stations_[0-9]{4}(_[0-9]{2}){2}_.*\\.csv', full.names = TRUE) %>% max()
stations_filename
stations <- fread(stations_filename, na.strings = c("")) 

stations <- stations[, .(id,total_docks)]
stations$id <- as.character(stations$id)
stations$total_docks <- as.integer(stations$total_docks)

head(fichier_stations)

fichier_stations <- stations[!duplicated(id),]


fichier_stations <- merge(fichier_stations,nc_stations, by="id")

```


# Exportation des fichiers qui seront utilisés dans Shiny
```{r}
fwrite(fichier_graphe, "graphes_matrice.csv")
fwrite(fichier_stations, "graphes_stations.csv")
```





##########################################################################################################
##########################################################################################################


## 2 - ANALYSE

# Construction de la matrice de co-occurences
```{r}
nb_min <- 5 * 30 # au moins un trajet par jour en moyenne
co_occ_oriented <- trips[,.N, by=.(from_station_id,to_station_id)][N>=nb_min]
```


```{r}
head(co_occ_oriented)
```

# Construction du graphe orienté à partir de la matrice de co-occurences
```{r}
g <- graph.data.frame(co_occ_oriented,directed = T)
```


# Première visualisation
```{r}
visIgraph(g)
```


# Est-ce que le graphe est connecté ? FALSE
```{r}
is.connected(g)
```

# Distribution des composantes connectées fortement (tous les noeuds peuvent être reliés dans les deux sens)
```{r}
components=components(g,"strong")
table(components$csize)
```

# Composantes faiblement connexes (connection faible ie le graph non orienté sous-jacent est connexe)
```{r}
components=components(g_tot,"weak")
table(components$csize)
```

On travaille par la suite sur le graphe orienté non connecté


## 3 - Paramètrage du graphe 
# Sommets
```{r}
vertices <- names(V(g))
vertices_info <- nc_stations[station_id %in% vertices]
head(vertices_info)
```
On pourrait ajouter la taille des noeuds = nombre de bornes

```{r}
edges <- as_ids(E(g))
head(edges)
```


```{r}
edges_mat<- do.call("rbind",strsplit(edges,"\\|"))
edges_df <- data.frame(edges_mat,stringsAsFactors = F)
names(edges_df) <- c("from_station_id","to_station_id")
head(edges_df)
```


# En cours : il faut attribuer les noms
```{r}
setkey(co_occ_oriented,from_station_id,to_station_id)
E(g)$weight <- co_occ_oriented[edges_df]$N

visIgraph(g)

```



## 4 - Métriques globales

# Densité : nombre de liens / nombre de liens possibles

```{r}
graph.density(g)
```

# Transitivité
```{r}
transitivity(g)
```

# Nombre moyen de voisins directs
```{r}
mean(degree(g))
```


# Distance moyenne entre deux noeuds du graphe
```{r}
average.path.length(g)
```

# La plus grande distance observée entre deux noeuds du graphe ie on ignore les noeuds non connectés
```{r}
E(g)$weight=1
diametre=diameter(g) 
diametre
```


## 5 - Métriques locales

# Avec les poids à 1
```{r}
E(g)$weight <- 1
centrality<-data.frame(index=V(g)$name, 
                       degre=degree(g,mode = "all"),#nombre de voisins directs
                       degre_in=degree(g,mode = "in"),#nombre de voisins qui émettent un flux vers le noeud
                       degre_out=degree(g,mode = "out"),#nombre de voisins qui reçoivent un flux du noeud

                       inter=betweenness(g), #intermédiarité ie nombre de fois que le noeud sert de plus court chemin
                       prox=closeness(g), #proximité, inverse de la distance moyenne du noeud vers n'importe quel autre
                       trans=transitivity(g,type="local"),
                       stringsAsFactors = F) #coefficient de clustering, on compte le nombre de triangles ie xRy & yRz => xRz
```

```{r}
head(centrality)
```
OK

# Avec les poids égaux au nombre de trajets
```{r}
E(g)$weight <- co_occ_oriented[edges_df]$N
centrality_w<-data.frame(index=V(g)$name,
                          degre_pondere=graph.strength(g,mode="all"), 
                          degre_pondere_out=graph.strength(g,mode="out"), 
                          degre_pondere_in=graph.strength(g,mode="in"), 
                          degre_pondere=graph.strength(g,mode="all"), 
                          inter_w=betweenness(g), #intermédiarité pondérée
                          prox_w=closeness(g),#proximité pondérée
                          trans_w=transitivity(g, type="local"))#coefficient de clustering pondéré
```

```{r}
head(centrality_w)
```
OK


```{r}
centrality <- merge(centrality,centrality_w,by="index")
centrality <- data.table(centrality)
setkey(centrality,index)
centrality <- centrality[names(V(g))]
```


```{r}
head(centrality)
```
OK

# Graphiques des mesures locales
```{r}

# mesure - PARAMETRE A FAIRE VARIER
#mesure <- centrality$degre
# mesure <- centrality$degre_pondere
 mesure <- centrality$prox
# mesure <- centrality$inter
# mesure <- centrality$trans[!is.nan(centrality$trans)]


col_split=cut(mesure,
              breaks = unique(quantile(mesure,0:9/9)),
              include.lowest = T)
ramp_pal=colorRampPalette(c("red","yellow","springgreen","royalblue"))
# ramp_pal=colorRampPalette(c("lightgrey","black"))

color_vector=ramp_pal(length(levels(col_split)))

V(g)$color=color_vector[col_split]
visFiness <- visIgraph(g, idToLabel = FALSE)
visFiness
```


## 6 - Analyse des communautés

# Recherche des cliques

```{r}
largest_cliques <- largest_cliques(g)[[1]]
print(paste("La plus grande clique (100% connectée) contient",length(largest_cliques),"stations."))
```


# Optimisation de la modularité - algorithme de Louvain

```{r}
c <- cluster_louvain(as.undirected(g)) # étude sur le graphe non orienté
# weights : Optional positive weight vector. If the graph has a weight edge attribute, then this is used by default. Supply NA here if the graph has a weight edge attribute, but you want to ignore it. Larger edge weights correspond to stronger connections.

modularity(c)
```

Nombre de groupes
```{r}
length(unique(c$membership))
```

Distribution de la taille des groupes
```{r}
table(c$membership)
```

visualisation
```{r}
col_split <- c$membership
ramp_pal <- colorRampPalette(c("red","yellow","springgreen","royalblue"))


color_vector <- ramp_pal(uniqueN(col_split))

V(g)$color=color_vector[col_split]
visFiness <- visIgraph(g, idToLabel = FALSE)
visFiness
```


