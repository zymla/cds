---
title: "Graph mining"
author: "Magda Bolewska"
date: "6 fÃ©vrier 2019"
output: html_document
---

## 1 - Importation de donnÃ©es et traitements prÃ©liminaires

```{r}
library(data.table)
library(lubridate)
library(magrittr)
library(igraph)
library(visNetwork)
```


```{r}

rm(trips)

trips_filename <- list.files('data_raw', pattern = 'divvy_trips_[0-9]{4}(_[0-9]{2}){2}_.*\\.csv', full.names = TRUE) %>% max()
trips_filename
trips <- fread(trips_filename, na.strings = c(""))

trips[
  , 
  `:=`(
    start_time = as_datetime(start_time),
    stop_time = as_datetime(stop_time)
  ), 
  ]

trips[, weekday := lubridate::wday(start_time, label=TRUE, abbr = FALSE)]
trips[, hr_depart := hour(start_time)]

```



# Attribution du nom et des coordonnÃ©es gÃ©ographiques uniques Ã  chaque station
```{r}

nc_stations <- trips[!duplicated(trips[, from_station_id]),.(from_station_id,from_station_name,from_latitude,from_longitude) ]

trips$from_station_name <- NULL
trips$from_latitude <- NULL
trips$from_longitude <- NULL
trips$to_station_name <- NULL
trips$to_latitude <- NULL
trips$to_longitude <- NULL



trips <- merge(trips,nc_stations,by= c("from_station_id"))

setnames(nc_stations, old = c("from_station_id", "from_station_name","from_latitude","from_longitude"), new = c("to_station_id", "to_station_name","to_latitude","to_longitude"))

trips <- merge(trips,nc_stations,by= c("to_station_id"))

trips$from_station_id <- as.character(trips$from_station_id)
trips$to_station_id <- as.character(trips$to_station_id)
summary(trips)

```


## 2 - Construction du graphe

# Construction de la matrice de co-occurences
```{r}
nb_min <- 5 * 30 # au moins un trajet par jour en moyenne
co_occ_oriented <- trips[,.N, by=.(from_station_id,to_station_id)][N>=nb_min]
```


```{r}
colnames(co_occ_oriented)
```

# Construction du graphe orientÃ© Ã  partie de la matrice de co-occurences
```{r}
g <- graph.data.frame(co_occ_oriented,directed = T)
```


# PremiÃ¨re visualisation
```{r}
visIgraph(g)
```


# Est-ce que le graphe est connectÃ© ? FALSE
```{r}
is.connected(g)
```

# Distribution des composantes connectÃ©es fortement (tous les noeuds peuvent Ãªtre reliÃ©s dans les deux sens)
```{r}
components=components(g,"strong")
table(components$csize)
```

# Composantes faiblement connexes (connection faible ie le graph non orientÃ© sous-jacent est connexe)
```{r}
components=components(g_tot,"weak")
table(components$csize)
```

On travaille par la suite sur le graphe orientÃ© non connectÃ©


## 3 - ParamÃ¨trage du graphe 
```{r}
vertices <- names(V(g))
```
On pourrait ajouter la taille des noeuds = nombre de bornes

```{r}
edges <- as_ids(E(g))
head(edges)
```


```{r}
edges_mat<- do.call("rbind",strsplit(edges,"\\|"))
edges_df <- data.frame(edges_mat,stringsAsFactors = F)
names(edges_df) <- c("from_station_id","to_station_id")
head(edges_df)
```

```{r}
setkey(co_occ_oriented,from_station_id,to_station_id)
E(g)$weight=co_occ_oriented[edges_df]$N
visIgraph(g)
```



## 4 - MÃ©triques globales

# DensitÃ© : nombre de liens / nombre de liens possibles

```{r}
graph.density(g)
```

# TransitivitÃ©
```{r}
transitivity(g)
```

# Nombre moyen de voisins directs
```{r}
mean(degree(g))
```


# Distance moyenne entre deux noeuds du graphe
```{r}
average.path.length(g)
```

# La plus grande distance observÃ©e entre deux noeuds du graphe ie on ignore les noeuds non connectÃ©s
```{r}
E(g)$weight=1
diametre=diameter(g) 
diametre
```


## 5 - MÃ©triques locales

# Avec les poids Ã  1
```{r}
E(g)$weight <- 1
centrality<-data.frame(index=V(g)$name, 
                       degre=degree(g,mode = "all"),#nombre de voisins directs
                       degre_in=degree(g,mode = "in"),#nombre de voisins qui Ã©mettent un flux vers le noeud
                       degre_out=degree(g,mode = "out"),#nombre de voisins qui reÃ§oivent un flux du noeud

                       inter=betweenness(g), #intermÃ©diaritÃ© ie nombre de fois que le noeud sert de plus court chemin
                       prox=closeness(g), #proximitÃ©, inverse de la distance moyenne du noeud vers n'importe quel autre
                       trans=transitivity(g,type="local"),
                       stringsAsFactors = F) #coefficient de clustering, on compte le nombre de triangles ie xRy & yRz => xRz
```

```{r}
head(centrality)
```
OK

# Avec les poids Ã©gaux au nombre de trajets
```{r}
E(g)$weight <- co_occ_oriented[edges_df]$N
centrality_w<-data.frame(index=V(g)$name,
                          degre_pondere=graph.strength(g,mode="all"), 
                          degre_pondere_out=graph.strength(g,mode="out"), 
                          degre_pondere_in=graph.strength(g,mode="in"), 
                          degre_pondere=graph.strength(g,mode="all"), 
                          inter_w=betweenness(g), #intermÃ©diaritÃ© pondÃ©rÃ©e
                          prox_w=closeness(g),#proximitÃ© pondÃ©rÃ©e
                          trans_w=transitivity(g, type="local"))#coefficient de clustering pondÃ©rÃ©
```

```{r}
head(centrality_w)
```
OK


```{r}
centrality <- merge(centrality,centrality_w,by="index")
centrality <- data.table(centrality)
setkey(centrality,index)
centrality <- centrality[names(V(g))]
```


```{r}
head(centrality)
```
OK

# Graphiques des mesures locales
```{r}

# mesure - PARAMETRE A FAIRE VARIER
mesure <- centrality$degre
# mesure <- centrality$degre_pondere
# mesure <- centrality$prox
# mesure <- centrality$inter
# mesure <- centrality$trans[!is.nan(centrality$trans)]


col_split=cut(mesure,
              breaks = unique(quantile(mesure,0:9/9)),
              include.lowest = T)
ramp_pal=colorRampPalette(c("red","yellow","springgreen","royalblue"))
# ramp_pal=colorRampPalette(c("lightgrey","black"))

color_vector=ramp_pal(length(levels(col_split)))

V(g)$color=color_vector[col_split]
visFiness <- visIgraph(g, idToLabel = FALSE)
visFiness
```


## 6 - Analyse des communautÃ©s
A faire :)


